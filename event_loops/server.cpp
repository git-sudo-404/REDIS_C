#include<stdio.h>
#include<stdlib.h>
#include<netinet/in.h>

using namespace std;


struct Conn{

  int fd = -1;

  bool want_read = false;
  bool want_write = false;
  bool want_close = false;

  vector<int> incoming ; // data to be parsed by application 
  vector<int> outgoing ; // data to be generated by application 

};


struct poll_fd{

  int fd;

  short events; // bitmask for POLLIN,POLLOUT,POLLERR --> what we want to do 
  short revents;  // returned by the kernal , indicating what events has occured among the ones you requested 

};


// what does blocking fd mean ?
//   --> Usually , the socket when performing read, write or accept it would wait for a connection or read or write to happen (Blocking in nature) 
//   --> But when you set the O_NONBLOCK flag the accept return -1 instead of waiting if there's no one to connect to  and sets the 
//       global error valuse errno to 'EAGAIN' or 'EWOULDBACK' 

static void fd_set_nb(int fd){          // sets the socket to be non - blocking 
  fcntl(fd,F_SETFL,fcntl(fd,F_GETFL,0)|O_NONBLOCK);     
}

static Conn *handle_accept(int fd){
  
  struct sockaddr_in client_addr = {};
  socketlen_t addrlen = sizeof(client_addr) ;

  int connfd = accept(fd,(struct sockaddr*)&client_addr,addrlen) ; // this accept is non - blocking since this handle_accept() function is called only after the poll() detects something

  if(connfd<0){
    return NULL ;
  }

  fd_set_nd(client_addr);

  Conn conn* = new Conn();
  conn->fd = connfd ;
  conn->want_read = true ; // read the first request 


  return conn;
  

}




int main(){

  std::vector<Conn *> fd2Conn ; // map of fd -> Conn , no need of hash_map since the fd's are generated sequentially from 3 
                                // starts from 3 , since 0,1,2 are reserved for terminal input, outputs anol . 

  std::vector<struct poll_fd> poll_args ; // tells poll() which fd's to listen to 
                                          // by default for every iteration it just starts with the server fd, listening for incoming requests 

  int fd = socket(AF_INET,SOCK_STREAM,0) ;

  int reuseaddr = 1;
  setsockopt(fd,SOL_SOCKET,REUSEADDR,&reuseaddr,sizeof(reuseaddr));

  struct sockaddr_in addr = {};
  
  addr.sin_family = "AF_INET" ;
  addr.sin_port = htons(1234) ;
  addt.sin_addr.s_addr = htonl(0) ;

  int rv = bind(fd,(const struct sockaddr*)&addr,sizeof(addr)) ;

  while(true){ // event loop 

    poll_args.clear() ;

    struct poll_fd pfd = {fd,POLLIN,0} ;

    poll_args.push_back(pfd) ; // put the listening socket in first position 

    // the rest of poll_args are connection sockets 

    for(Conn *conn : fd2Conn){
      if(!conn)
        continue;

      struct poll_fd pfd = {conn->fd,POLLERR,0};

      if(conn->want_read){
        pfd.events |= POLLIN ;
      }

      if(conn->want_write){
        pfd.events |= POLLOUT ;
      }
  
      poll_args.pb(pfd) ;

    }

    // call poll()

    int rv = poll(poll_args.data(),(nfds_t)poll_args.size(),-1) ;
  
    if(rv<0 && errno = EINTR){
      continue;
    }

    if(rv<0){
      perror("Poll()");
      exit(1);
    }


    // handle the listening socket 

    if(poll_args[0].revents){

      if(Conn *conn = handle_accept(fd)) {    // has an underlying accept() and creates a conn struct and sends it back 

        if(fd2Conn.size() <= (size_t)conn->fd){     // if the vector is too small to hold the new connection 

          fd2Conn.resize(conn->fd + 1);     // increase the size of the vector

        }

        fd2Conn[conn->fd] = conn;     //  and assign it in the index equal to its fd 


      }

    }

    // handle connections 

    for(int i=1;i<=poll_args.size();i++){

      uint32_t ready = poll_args[i].revents ;
      Conn *conn = fd2Conn[poll_args[i].fd] ;

      if(ready & POLLIN){
        handle_read(conn) ;
      }


      if(ready & POLLOUT){
        handle_write(conn) ;
      }

      if(ready & POLLERR || conn->want_close){
        close(conn->fd) ;
        fd2Conn[conn->fd] = NULL ;
        delete conn ;
      }

    } 

     


  }

}
