#include<stdio.h>
#include<stdlib.h>
#include<netinet/in.h>

using namespace std;


struct Conn{

  int fd = -1;

  bool want_read = false;
  bool want_write = false;
  bool want_close = false;

  vector<int> incoming ; // data to be parsed by application 
  vector<int> outgoing ; // data to be generated by application 

};


struct poll_fd{

  int fd;

  short events; // bitmask for POLLIN,POLLOUT,POLLERR --> what we want to do 
  short revents;  // returned by the kernal , indicating what events has occured among the ones you requested 

};

int main(){

  std::vector<Conn *> fd2Conn ; // map of fd -> Conn , no need of hash_map since the fd's are generated sequentially from 3 
                                // starts from 3 , since 0,1,2 are reserved for terminal input, outputs anol . 

  std::vector<struct poll_fd> poll_args ; // tells poll() which fd's to listen to 
                                          // by default for every iteration it just starts with the server fd, listening for incoming requests 

  int fd = socket(AF_INET,SOCK_STREAM,0) ;

  int reuseaddr = 1;
  setsockopt(fd,SOL_SOCKET,REUSEADDR,&reuseaddr,sizeof(reuseaddr));

  struct sockaddr_in addr = {};
  
  addr.sin_family = "AF_INET" ;
  addr.sin_port = htons(1234) ;
  addt.sin_addr.s_addr = htonl(0) ;

  int rv = bind(fd,(const struct sockaddr*)&addr,sizeof(addr)) ;

  while(true){ // event loop 

    poll_args.clear() ;

    struct poll_fd pfd = {fd,POLLIN,0} ;

    poll_args.push_back(pfd) ; // put the listening socket in first position 

    // the rest of poll_args are connection sockets 

    for(Conn *conn : fd2Conn){
      if(!conn)
        continue;

      struct poll_fd pfd = {conn->fd,POLLERR,0};

      if(conn->want_read){
        pfd.events |= POLLIN ;
      }

      if(conn->want_write){
        pfd.events |= POLLOUT ;
      }
  
      poll_args.pb(pfd) ;

    }

    // call poll()

    int rv = poll(poll_args.data(),(nfds_t)poll_args.size(),-1) ;
  
    if(rv<0 && errno = EINTR){
      continue;
    }

    if(rv<0){
      perror("Poll()");
      exit(1);
    }


    // handle the listening socket 

    if(poll_args[0].revents){

      if(Conn *conn = handle_accept(fd)) {

        if(fd2Conn.size() <= (size_t)conn->fd){

          fd2Conn.resize(conn->fd + 1);

        }

        fd2Conn[conn->fd] = conn ;

      }

    }

  }

}
